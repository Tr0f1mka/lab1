"""------------------------------------
   --парсер арифметического выражения--
   ------------------------------------
"""



"""-------------библиотеки-------------"""

from src.patterns import TOKEN_RE   #type: ignore  # noqa: E402


"""----------функции----------"""

def tokens(s: str) -> list[str] | str:
    """
    Парсер математического выражения
    :param s: Строка, являющаяся математическим выражением
    :return: Список строк, состоящий из элементов математического выражения, или строка - сообщение об ошибке
    """

    arr_tokens = [m.group(1) for m in TOKEN_RE.finditer(s)]    #Разбиваем строку на токены
    if ("abs" in arr_tokens) or ("sqrt" in arr_tokens) or ("pow" in arr_tokens) or ("max" in arr_tokens) or ("min" in arr_tokens):    #Если есть токены названий функций, собираем её елементы вместе
        flag = False    #Флаг сборки функции
        elem = ""       #Переменная сборки функции
        cnt_bracket = 0    #Счётчик открытых скобок
        new_arr_tokens = []   #Новый список токенов

        for i in range(len(arr_tokens)):      #Проходим циклом по списку токенов
            if flag:      #Если флаг поднят (собираем функцию)
                if arr_tokens[i] == "(":     #Если текущий токен - "(", прибавить 1 к счётчику открытых скобок
                    cnt_bracket += 1
                elif arr_tokens[i] == ")":   #Если текущий токен - ")", вычесть 1 к счётчику открытых скобок
                    cnt_bracket -= 1

                elem += arr_tokens[i]     #Присоединяем токен к переменной сборки функции, разделяя их пробелом
                elem += " "
                if cnt_bracket == 0:      #Если все скобки закрыты, опускаем флаг, кладём токен функции в новый список токенов и очищаем переменную сборки функции
                    flag = False
                    new_arr_tokens.append(elem[:-1])
                    elem = ""

            else:         #Если флаг опущен (не собираем функцию)
                if (arr_tokens[i] == "abs") or (arr_tokens[i] == "sqrt") or (arr_tokens[i] == "pow") or (arr_tokens[i] == "max") or (arr_tokens[i] == "min"):  #Если текущий токен - название функции
                    if i+1 != len(arr_tokens):         #Если название функции не является последним элементом
                        if arr_tokens[i+1] == "(":     #Если следующий токен - открывающая скобка, поднимаем флаг и добавляем название функции в переменную сборки функции
                            elem = arr_tokens[i]
                            flag = True

                        else:          #Если сразу после объявления функции нет "(", возвращаем ошибку
                            return "После названия функции должны идти аргументы(в скобках)"
                    else:       #Если название функции - последний токен, возвращаем ошибку
                        return "После названия функции должны идти аргументы(в скобках)"
                else:    #Если токен - не название функции, добавляем его в новый список токенов
                    new_arr_tokens.append(arr_tokens[i])

        if cnt_bracket != 0:    #Если у функции отсутствует закрывающая скобка, возвращаем ошибку
            return "Аргументы функции должны быть в скобках"
        return new_arr_tokens

    else:     #Если нет функций в списке токенов, возвращаем его
        return arr_tokens
